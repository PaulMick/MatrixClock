#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_rom_sys.h"
#include "esp_heap_caps.h"

#include "display_driver.h"

// Board dependent
#define R1 9
#define G1 10
#define B1 11
#define R2 12
#define G2 13
#define B2 14

// Board dependent
#define A 35
#define B 45
#define C 48
#define D 47
#define CLK 21
#define LAT 20
#define OE 19

#define DISPLAY_WIDTH 64 // Horizontal pixel count of display
#define DISPLAY_HEIGHT 32 // Vertical pixel count of display
#define COLOR_DEPTH 4 // Bit depth of each of the 3 color channels
#define SCAN_LINES 2 // 1/16 -> 2 lines are scanned at a time (1/16th of the display is scanned at a time)

#define I2S_SAMPLE_RATE 150000
#define BASE_DELAY_US 200 // Shortest delay used for I2S

// Double frame buffer
uint8_t frame_buf_in[DISPLAY_HEIGHT][DISPLAY_WIDTH][3];
uint8_t frame_buf_out[DISPLAY_HEIGHT][DISPLAY_WIDTH][3];
// Frame buffer pointers
uint8_t (*frame_buf_in_ptr)[DISPLAY_HEIGHT][DISPLAY_WIDTH][3] = &frame_buf_in;
uint8_t (*frame_buf_out_ptr)[DISPLAY_HEIGHT][DISPLAY_WIDTH][3] = &frame_buf_out;
// Temp pointer for swapping frame buffer pointers
uint8_t (*tmp)[DISPLAY_HEIGHT][DISPLAY_WIDTH][3];
int swap = 0;

// Indicator of whether the in frame buffer is completed
int in_done = 0;
int *in_done_ptr = &in_done;

// Scanning bitplanes used to correctly format row pixel data into the correct format for RGB channel PWM
uint8_t *bitplane_buf[COLOR_DEPTH];

// Get a display handle
DisplayHandle get_display_handle() {
    DisplayHandle display_handle = {
        .width = DISPLAY_WIDTH,
        .height = DISPLAY_HEIGHT,
        .frame_buf_ptr = frame_buf_in_ptr,
        .in_done_ptr = in_done_ptr
    };
    return display_handle;
}

// Prepare the bitplanes for a pair of rows
void prep_bitplanes(uint8_t row) {
    // Add color channels in by bit depth
    for (int depth = 0; depth < COLOR_DEPTH; depth ++) {
        // Add the bit at the current bit depth from every pixel in the row to the bitplane
        for (int col = 0; col < DISPLAY_WIDTH; col ++) {
            uint8_t r1 = *frame_buf_out_ptr[row][col][0];
            uint8_t g1 = *frame_buf_out_ptr[row][col][1];
            uint8_t b1 = *frame_buf_out_ptr[row][col][2];
            uint8_t r2 = *frame_buf_out_ptr[row + DISPLAY_HEIGHT / SCAN_LINES][col][0];
            uint8_t g2 = *frame_buf_out_ptr[row + DISPLAY_HEIGHT / SCAN_LINES][col][1];
            uint8_t b2 = *frame_buf_out_ptr[row + DISPLAY_HEIGHT / SCAN_LINES][col][2];
            uint8_t rgb_bit_slice = 0;
            rgb_bit_slice |= ((r1 >> (7 - depth)) & 1) << 0;
            rgb_bit_slice |= ((g1 >> (7 - depth)) & 1) << 1;
            rgb_bit_slice |= ((b1 >> (7 - depth)) & 1) << 2;
            rgb_bit_slice |= ((r2 >> (7 - depth)) & 1) << 3;
            rgb_bit_slice |= ((g2 >> (7 - depth)) & 1) << 4;
            rgb_bit_slice |= ((b2 >> (7 - depth)) & 1) << 5;
            bitplane_buf[depth][col] = rgb_bit_slice;
        }
    }
}

void refresh_task(void *param) {
    while (1) {
        if (*in_done_ptr) {
            swap_frame_buffers();
            *in_done_ptr = 0;
        }
        // Main render
        for (uint8_t row = 0; row < (uint8_t) (DISPLAY_HEIGHT / SCAN_LINES); row ++) {
            // Prepare the bitplanes
            prep_bitplanes();
            // Set the row
            gpio_set_level(A, row & 0x01);
            gpio_set_level(B, row & 0x02);
            gpio_set_level(C, row & 0x04);
            gpio_set_level(D, row & 0x08);
            // Enable
            gpio_set_level(OE, 1);
            // Set top pixel and bottom pixel with bcm
            for (int depth = 0; depth < COLOR_DEPTH; depth ++) {
                gpio_set_level(R1, );
                gpio_set_level(R1, );
                gpio_set_level(R1, );
                gpio_set_level(R1, );
                gpio_set_level(R1, );
                gpio_set_level(R1, );
            }
            // Latch to 
            // Disable
            gpio_set_level(OE, 0);
        }
        // End main render
        vTaskDelay(10 / portTICK_PERIOD_MS);
    }
}

// Call this to start the display refresh task
void run_refresh() {

    for (int bit_depth = 0; bit_depth < COLOR_DEPTH; bit_depth ++) {
        bitplane_buf[bit_depth] = heap_caps_malloc(DISPLAY_WIDTH, MALLOC_CAP_DMA);
        memset(bitplane_buf[bit_depth], 0, DISPLAY_WIDTH);
    }

    for (int y = 0; y < DISPLAY_HEIGHT; y ++) {
        for (int x = 0; x < DISPLAY_WIDTH; x ++) {
            frame_buf_in[y][x][0] = x;
            frame_buf_in[y][x][1] = y;
            frame_buf_in[y][x][2] = x + y;
        }
    }

    for (int y = 0; y < DISPLAY_HEIGHT; y ++) {
        for (int x = 0; x < DISPLAY_WIDTH; x ++) {
            frame_buf_out[y][x][0] = x;
            frame_buf_out[y][x][1] = y;
            frame_buf_out[y][x][2] = x + y;
        }
    }

    xTaskCreatePinnedToCore(refresh_task, "Refresh Task", 4096, xTaskGetCurrentTaskHandle(), 10, NULL, 1);
}